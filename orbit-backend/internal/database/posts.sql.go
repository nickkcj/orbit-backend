// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: posts.sql

package database

import (
	"context"
	"database/sql"
	"time"

	"github.com/google/uuid"
)

const archivePost = `-- name: ArchivePost :exec
UPDATE posts SET status = 'archived', updated_at = NOW() WHERE id = $1
`

func (q *Queries) ArchivePost(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, archivePost, id)
	return err
}

const createPost = `-- name: CreatePost :one
INSERT INTO posts (tenant_id, category_id, author_id, title, slug, content, content_format, excerpt, cover_image_url, status)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10)
RETURNING id, tenant_id, category_id, author_id, title, slug, content, content_format, excerpt, cover_image_url, status, published_at, view_count, like_count, comment_count, created_at, updated_at
`

type CreatePostParams struct {
	TenantID      uuid.UUID      `json:"tenant_id"`
	CategoryID    uuid.NullUUID  `json:"category_id"`
	AuthorID      uuid.UUID      `json:"author_id"`
	Title         string         `json:"title"`
	Slug          string         `json:"slug"`
	Content       sql.NullString `json:"content"`
	ContentFormat string         `json:"content_format"`
	Excerpt       sql.NullString `json:"excerpt"`
	CoverImageUrl sql.NullString `json:"cover_image_url"`
	Status        string         `json:"status"`
}

func (q *Queries) CreatePost(ctx context.Context, arg CreatePostParams) (Post, error) {
	row := q.db.QueryRowContext(ctx, createPost,
		arg.TenantID,
		arg.CategoryID,
		arg.AuthorID,
		arg.Title,
		arg.Slug,
		arg.Content,
		arg.ContentFormat,
		arg.Excerpt,
		arg.CoverImageUrl,
		arg.Status,
	)
	var i Post
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.CategoryID,
		&i.AuthorID,
		&i.Title,
		&i.Slug,
		&i.Content,
		&i.ContentFormat,
		&i.Excerpt,
		&i.CoverImageUrl,
		&i.Status,
		&i.PublishedAt,
		&i.ViewCount,
		&i.LikeCount,
		&i.CommentCount,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const decrementPostLikes = `-- name: DecrementPostLikes :exec
UPDATE posts SET like_count = like_count - 1 WHERE id = $1 AND like_count > 0
`

func (q *Queries) DecrementPostLikes(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, decrementPostLikes, id)
	return err
}

const deletePost = `-- name: DeletePost :exec
DELETE FROM posts WHERE id = $1
`

func (q *Queries) DeletePost(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, deletePost, id)
	return err
}

const getPostByID = `-- name: GetPostByID :one
SELECT id, tenant_id, category_id, author_id, title, slug, content, content_format, excerpt, cover_image_url, status, published_at, view_count, like_count, comment_count, created_at, updated_at FROM posts WHERE id = $1
`

func (q *Queries) GetPostByID(ctx context.Context, id uuid.UUID) (Post, error) {
	row := q.db.QueryRowContext(ctx, getPostByID, id)
	var i Post
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.CategoryID,
		&i.AuthorID,
		&i.Title,
		&i.Slug,
		&i.Content,
		&i.ContentFormat,
		&i.Excerpt,
		&i.CoverImageUrl,
		&i.Status,
		&i.PublishedAt,
		&i.ViewCount,
		&i.LikeCount,
		&i.CommentCount,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getPostBySlug = `-- name: GetPostBySlug :one
SELECT id, tenant_id, category_id, author_id, title, slug, content, content_format, excerpt, cover_image_url, status, published_at, view_count, like_count, comment_count, created_at, updated_at FROM posts WHERE tenant_id = $1 AND slug = $2
`

type GetPostBySlugParams struct {
	TenantID uuid.UUID `json:"tenant_id"`
	Slug     string    `json:"slug"`
}

func (q *Queries) GetPostBySlug(ctx context.Context, arg GetPostBySlugParams) (Post, error) {
	row := q.db.QueryRowContext(ctx, getPostBySlug, arg.TenantID, arg.Slug)
	var i Post
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.CategoryID,
		&i.AuthorID,
		&i.Title,
		&i.Slug,
		&i.Content,
		&i.ContentFormat,
		&i.Excerpt,
		&i.CoverImageUrl,
		&i.Status,
		&i.PublishedAt,
		&i.ViewCount,
		&i.LikeCount,
		&i.CommentCount,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const incrementPostLikes = `-- name: IncrementPostLikes :exec
UPDATE posts SET like_count = like_count + 1 WHERE id = $1
`

func (q *Queries) IncrementPostLikes(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, incrementPostLikes, id)
	return err
}

const incrementPostViews = `-- name: IncrementPostViews :exec
UPDATE posts SET view_count = view_count + 1 WHERE id = $1
`

func (q *Queries) IncrementPostViews(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, incrementPostViews, id)
	return err
}

const listPostsByAuthor = `-- name: ListPostsByAuthor :many
SELECT id, tenant_id, category_id, author_id, title, slug, content, content_format, excerpt, cover_image_url, status, published_at, view_count, like_count, comment_count, created_at, updated_at FROM posts
WHERE tenant_id = $1 AND author_id = $2
ORDER BY created_at DESC
`

type ListPostsByAuthorParams struct {
	TenantID uuid.UUID `json:"tenant_id"`
	AuthorID uuid.UUID `json:"author_id"`
}

func (q *Queries) ListPostsByAuthor(ctx context.Context, arg ListPostsByAuthorParams) ([]Post, error) {
	rows, err := q.db.QueryContext(ctx, listPostsByAuthor, arg.TenantID, arg.AuthorID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Post
	for rows.Next() {
		var i Post
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.CategoryID,
			&i.AuthorID,
			&i.Title,
			&i.Slug,
			&i.Content,
			&i.ContentFormat,
			&i.Excerpt,
			&i.CoverImageUrl,
			&i.Status,
			&i.PublishedAt,
			&i.ViewCount,
			&i.LikeCount,
			&i.CommentCount,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPostsByCategory = `-- name: ListPostsByCategory :many
SELECT
    p.id, p.tenant_id, p.category_id, p.author_id, p.title, p.slug, p.content, p.content_format, p.excerpt, p.cover_image_url, p.status, p.published_at, p.view_count, p.like_count, p.comment_count, p.created_at, p.updated_at,
    u.name as author_name,
    u.avatar_url as author_avatar
FROM posts p
JOIN users u ON p.author_id = u.id
WHERE p.tenant_id = $1 AND p.category_id = $2 AND p.status = 'published'
ORDER BY p.published_at DESC
LIMIT $3 OFFSET $4
`

type ListPostsByCategoryParams struct {
	TenantID   uuid.UUID     `json:"tenant_id"`
	CategoryID uuid.NullUUID `json:"category_id"`
	Limit      int32         `json:"limit"`
	Offset     int32         `json:"offset"`
}

type ListPostsByCategoryRow struct {
	ID            uuid.UUID      `json:"id"`
	TenantID      uuid.UUID      `json:"tenant_id"`
	CategoryID    uuid.NullUUID  `json:"category_id"`
	AuthorID      uuid.UUID      `json:"author_id"`
	Title         string         `json:"title"`
	Slug          string         `json:"slug"`
	Content       sql.NullString `json:"content"`
	ContentFormat string         `json:"content_format"`
	Excerpt       sql.NullString `json:"excerpt"`
	CoverImageUrl sql.NullString `json:"cover_image_url"`
	Status        string         `json:"status"`
	PublishedAt   sql.NullTime   `json:"published_at"`
	ViewCount     int32          `json:"view_count"`
	LikeCount     int32          `json:"like_count"`
	CommentCount  int32          `json:"comment_count"`
	CreatedAt     time.Time      `json:"created_at"`
	UpdatedAt     time.Time      `json:"updated_at"`
	AuthorName    string         `json:"author_name"`
	AuthorAvatar  sql.NullString `json:"author_avatar"`
}

func (q *Queries) ListPostsByCategory(ctx context.Context, arg ListPostsByCategoryParams) ([]ListPostsByCategoryRow, error) {
	rows, err := q.db.QueryContext(ctx, listPostsByCategory,
		arg.TenantID,
		arg.CategoryID,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListPostsByCategoryRow
	for rows.Next() {
		var i ListPostsByCategoryRow
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.CategoryID,
			&i.AuthorID,
			&i.Title,
			&i.Slug,
			&i.Content,
			&i.ContentFormat,
			&i.Excerpt,
			&i.CoverImageUrl,
			&i.Status,
			&i.PublishedAt,
			&i.ViewCount,
			&i.LikeCount,
			&i.CommentCount,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.AuthorName,
			&i.AuthorAvatar,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPostsByTenant = `-- name: ListPostsByTenant :many
SELECT
    p.id, p.tenant_id, p.category_id, p.author_id, p.title, p.slug, p.content, p.content_format, p.excerpt, p.cover_image_url, p.status, p.published_at, p.view_count, p.like_count, p.comment_count, p.created_at, p.updated_at,
    u.name as author_name,
    u.avatar_url as author_avatar,
    c.name as category_name
FROM posts p
JOIN users u ON p.author_id = u.id
LEFT JOIN categories c ON p.category_id = c.id
WHERE p.tenant_id = $1 AND p.status = 'published'
ORDER BY p.published_at DESC
LIMIT $2 OFFSET $3
`

type ListPostsByTenantParams struct {
	TenantID uuid.UUID `json:"tenant_id"`
	Limit    int32     `json:"limit"`
	Offset   int32     `json:"offset"`
}

type ListPostsByTenantRow struct {
	ID            uuid.UUID      `json:"id"`
	TenantID      uuid.UUID      `json:"tenant_id"`
	CategoryID    uuid.NullUUID  `json:"category_id"`
	AuthorID      uuid.UUID      `json:"author_id"`
	Title         string         `json:"title"`
	Slug          string         `json:"slug"`
	Content       sql.NullString `json:"content"`
	ContentFormat string         `json:"content_format"`
	Excerpt       sql.NullString `json:"excerpt"`
	CoverImageUrl sql.NullString `json:"cover_image_url"`
	Status        string         `json:"status"`
	PublishedAt   sql.NullTime   `json:"published_at"`
	ViewCount     int32          `json:"view_count"`
	LikeCount     int32          `json:"like_count"`
	CommentCount  int32          `json:"comment_count"`
	CreatedAt     time.Time      `json:"created_at"`
	UpdatedAt     time.Time      `json:"updated_at"`
	AuthorName    string         `json:"author_name"`
	AuthorAvatar  sql.NullString `json:"author_avatar"`
	CategoryName  sql.NullString `json:"category_name"`
}

func (q *Queries) ListPostsByTenant(ctx context.Context, arg ListPostsByTenantParams) ([]ListPostsByTenantRow, error) {
	rows, err := q.db.QueryContext(ctx, listPostsByTenant, arg.TenantID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListPostsByTenantRow
	for rows.Next() {
		var i ListPostsByTenantRow
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.CategoryID,
			&i.AuthorID,
			&i.Title,
			&i.Slug,
			&i.Content,
			&i.ContentFormat,
			&i.Excerpt,
			&i.CoverImageUrl,
			&i.Status,
			&i.PublishedAt,
			&i.ViewCount,
			&i.LikeCount,
			&i.CommentCount,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.AuthorName,
			&i.AuthorAvatar,
			&i.CategoryName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const publishPost = `-- name: PublishPost :one
UPDATE posts
SET status = 'published', published_at = NOW(), updated_at = NOW()
WHERE id = $1
RETURNING id, tenant_id, category_id, author_id, title, slug, content, content_format, excerpt, cover_image_url, status, published_at, view_count, like_count, comment_count, created_at, updated_at
`

func (q *Queries) PublishPost(ctx context.Context, id uuid.UUID) (Post, error) {
	row := q.db.QueryRowContext(ctx, publishPost, id)
	var i Post
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.CategoryID,
		&i.AuthorID,
		&i.Title,
		&i.Slug,
		&i.Content,
		&i.ContentFormat,
		&i.Excerpt,
		&i.CoverImageUrl,
		&i.Status,
		&i.PublishedAt,
		&i.ViewCount,
		&i.LikeCount,
		&i.CommentCount,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updatePost = `-- name: UpdatePost :one
UPDATE posts
SET title = $2, content = $3, excerpt = $4, cover_image_url = $5, category_id = $6, updated_at = NOW()
WHERE id = $1
RETURNING id, tenant_id, category_id, author_id, title, slug, content, content_format, excerpt, cover_image_url, status, published_at, view_count, like_count, comment_count, created_at, updated_at
`

type UpdatePostParams struct {
	ID            uuid.UUID      `json:"id"`
	Title         string         `json:"title"`
	Content       sql.NullString `json:"content"`
	Excerpt       sql.NullString `json:"excerpt"`
	CoverImageUrl sql.NullString `json:"cover_image_url"`
	CategoryID    uuid.NullUUID  `json:"category_id"`
}

func (q *Queries) UpdatePost(ctx context.Context, arg UpdatePostParams) (Post, error) {
	row := q.db.QueryRowContext(ctx, updatePost,
		arg.ID,
		arg.Title,
		arg.Content,
		arg.Excerpt,
		arg.CoverImageUrl,
		arg.CategoryID,
	)
	var i Post
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.CategoryID,
		&i.AuthorID,
		&i.Title,
		&i.Slug,
		&i.Content,
		&i.ContentFormat,
		&i.Excerpt,
		&i.CoverImageUrl,
		&i.Status,
		&i.PublishedAt,
		&i.ViewCount,
		&i.LikeCount,
		&i.CommentCount,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
