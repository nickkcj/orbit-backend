// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: videos.sql

package database

import (
	"context"
	"database/sql"
	"time"

	"github.com/google/uuid"
)

const attachVideoToPost = `-- name: AttachVideoToPost :exec
UPDATE videos SET post_id = $2, updated_at = NOW() WHERE id = $1
`

type AttachVideoToPostParams struct {
	ID     uuid.UUID     `json:"id"`
	PostID uuid.NullUUID `json:"post_id"`
}

func (q *Queries) AttachVideoToPost(ctx context.Context, arg AttachVideoToPostParams) error {
	_, err := q.db.ExecContext(ctx, attachVideoToPost, arg.ID, arg.PostID)
	return err
}

const createVideo = `-- name: CreateVideo :one
INSERT INTO videos (tenant_id, uploader_id, title, description, provider, status)
VALUES ($1, $2, $3, $4, $5, 'pending')
RETURNING id, tenant_id, uploader_id, title, description, external_id, provider, original_url, playback_url, thumbnail_url, duration_seconds, file_size_bytes, resolution, status, error_message, post_id, created_at, updated_at
`

type CreateVideoParams struct {
	TenantID    uuid.UUID      `json:"tenant_id"`
	UploaderID  uuid.UUID      `json:"uploader_id"`
	Title       string         `json:"title"`
	Description sql.NullString `json:"description"`
	Provider    string         `json:"provider"`
}

func (q *Queries) CreateVideo(ctx context.Context, arg CreateVideoParams) (Video, error) {
	row := q.db.QueryRowContext(ctx, createVideo,
		arg.TenantID,
		arg.UploaderID,
		arg.Title,
		arg.Description,
		arg.Provider,
	)
	var i Video
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.UploaderID,
		&i.Title,
		&i.Description,
		&i.ExternalID,
		&i.Provider,
		&i.OriginalUrl,
		&i.PlaybackUrl,
		&i.ThumbnailUrl,
		&i.DurationSeconds,
		&i.FileSizeBytes,
		&i.Resolution,
		&i.Status,
		&i.ErrorMessage,
		&i.PostID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteVideo = `-- name: DeleteVideo :exec
DELETE FROM videos WHERE id = $1
`

func (q *Queries) DeleteVideo(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, deleteVideo, id)
	return err
}

const getVideoByExternalID = `-- name: GetVideoByExternalID :one
SELECT id, tenant_id, uploader_id, title, description, external_id, provider, original_url, playback_url, thumbnail_url, duration_seconds, file_size_bytes, resolution, status, error_message, post_id, created_at, updated_at FROM videos WHERE provider = $1 AND external_id = $2
`

type GetVideoByExternalIDParams struct {
	Provider   string         `json:"provider"`
	ExternalID sql.NullString `json:"external_id"`
}

func (q *Queries) GetVideoByExternalID(ctx context.Context, arg GetVideoByExternalIDParams) (Video, error) {
	row := q.db.QueryRowContext(ctx, getVideoByExternalID, arg.Provider, arg.ExternalID)
	var i Video
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.UploaderID,
		&i.Title,
		&i.Description,
		&i.ExternalID,
		&i.Provider,
		&i.OriginalUrl,
		&i.PlaybackUrl,
		&i.ThumbnailUrl,
		&i.DurationSeconds,
		&i.FileSizeBytes,
		&i.Resolution,
		&i.Status,
		&i.ErrorMessage,
		&i.PostID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getVideoByID = `-- name: GetVideoByID :one
SELECT id, tenant_id, uploader_id, title, description, external_id, provider, original_url, playback_url, thumbnail_url, duration_seconds, file_size_bytes, resolution, status, error_message, post_id, created_at, updated_at FROM videos WHERE id = $1
`

func (q *Queries) GetVideoByID(ctx context.Context, id uuid.UUID) (Video, error) {
	row := q.db.QueryRowContext(ctx, getVideoByID, id)
	var i Video
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.UploaderID,
		&i.Title,
		&i.Description,
		&i.ExternalID,
		&i.Provider,
		&i.OriginalUrl,
		&i.PlaybackUrl,
		&i.ThumbnailUrl,
		&i.DurationSeconds,
		&i.FileSizeBytes,
		&i.Resolution,
		&i.Status,
		&i.ErrorMessage,
		&i.PostID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listVideosByPost = `-- name: ListVideosByPost :many
SELECT id, tenant_id, uploader_id, title, description, external_id, provider, original_url, playback_url, thumbnail_url, duration_seconds, file_size_bytes, resolution, status, error_message, post_id, created_at, updated_at FROM videos WHERE post_id = $1 AND status = 'ready'
`

func (q *Queries) ListVideosByPost(ctx context.Context, postID uuid.NullUUID) ([]Video, error) {
	rows, err := q.db.QueryContext(ctx, listVideosByPost, postID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Video
	for rows.Next() {
		var i Video
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.UploaderID,
			&i.Title,
			&i.Description,
			&i.ExternalID,
			&i.Provider,
			&i.OriginalUrl,
			&i.PlaybackUrl,
			&i.ThumbnailUrl,
			&i.DurationSeconds,
			&i.FileSizeBytes,
			&i.Resolution,
			&i.Status,
			&i.ErrorMessage,
			&i.PostID,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listVideosByTenant = `-- name: ListVideosByTenant :many
SELECT
    v.id, v.tenant_id, v.uploader_id, v.title, v.description, v.external_id, v.provider, v.original_url, v.playback_url, v.thumbnail_url, v.duration_seconds, v.file_size_bytes, v.resolution, v.status, v.error_message, v.post_id, v.created_at, v.updated_at,
    u.name as uploader_name
FROM videos v
JOIN users u ON v.uploader_id = u.id
WHERE v.tenant_id = $1 AND v.status = 'ready'
ORDER BY v.created_at DESC
LIMIT $2 OFFSET $3
`

type ListVideosByTenantParams struct {
	TenantID uuid.UUID `json:"tenant_id"`
	Limit    int32     `json:"limit"`
	Offset   int32     `json:"offset"`
}

type ListVideosByTenantRow struct {
	ID              uuid.UUID      `json:"id"`
	TenantID        uuid.UUID      `json:"tenant_id"`
	UploaderID      uuid.UUID      `json:"uploader_id"`
	Title           string         `json:"title"`
	Description     sql.NullString `json:"description"`
	ExternalID      sql.NullString `json:"external_id"`
	Provider        string         `json:"provider"`
	OriginalUrl     sql.NullString `json:"original_url"`
	PlaybackUrl     sql.NullString `json:"playback_url"`
	ThumbnailUrl    sql.NullString `json:"thumbnail_url"`
	DurationSeconds sql.NullInt32  `json:"duration_seconds"`
	FileSizeBytes   sql.NullInt64  `json:"file_size_bytes"`
	Resolution      sql.NullString `json:"resolution"`
	Status          string         `json:"status"`
	ErrorMessage    sql.NullString `json:"error_message"`
	PostID          uuid.NullUUID  `json:"post_id"`
	CreatedAt       time.Time      `json:"created_at"`
	UpdatedAt       time.Time      `json:"updated_at"`
	UploaderName    string         `json:"uploader_name"`
}

func (q *Queries) ListVideosByTenant(ctx context.Context, arg ListVideosByTenantParams) ([]ListVideosByTenantRow, error) {
	rows, err := q.db.QueryContext(ctx, listVideosByTenant, arg.TenantID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListVideosByTenantRow
	for rows.Next() {
		var i ListVideosByTenantRow
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.UploaderID,
			&i.Title,
			&i.Description,
			&i.ExternalID,
			&i.Provider,
			&i.OriginalUrl,
			&i.PlaybackUrl,
			&i.ThumbnailUrl,
			&i.DurationSeconds,
			&i.FileSizeBytes,
			&i.Resolution,
			&i.Status,
			&i.ErrorMessage,
			&i.PostID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.UploaderName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateVideoAfterProcessing = `-- name: UpdateVideoAfterProcessing :one
UPDATE videos
SET
    external_id = $2,
    playback_url = $3,
    thumbnail_url = $4,
    duration_seconds = $5,
    resolution = $6,
    status = 'ready',
    updated_at = NOW()
WHERE id = $1
RETURNING id, tenant_id, uploader_id, title, description, external_id, provider, original_url, playback_url, thumbnail_url, duration_seconds, file_size_bytes, resolution, status, error_message, post_id, created_at, updated_at
`

type UpdateVideoAfterProcessingParams struct {
	ID              uuid.UUID      `json:"id"`
	ExternalID      sql.NullString `json:"external_id"`
	PlaybackUrl     sql.NullString `json:"playback_url"`
	ThumbnailUrl    sql.NullString `json:"thumbnail_url"`
	DurationSeconds sql.NullInt32  `json:"duration_seconds"`
	Resolution      sql.NullString `json:"resolution"`
}

func (q *Queries) UpdateVideoAfterProcessing(ctx context.Context, arg UpdateVideoAfterProcessingParams) (Video, error) {
	row := q.db.QueryRowContext(ctx, updateVideoAfterProcessing,
		arg.ID,
		arg.ExternalID,
		arg.PlaybackUrl,
		arg.ThumbnailUrl,
		arg.DurationSeconds,
		arg.Resolution,
	)
	var i Video
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.UploaderID,
		&i.Title,
		&i.Description,
		&i.ExternalID,
		&i.Provider,
		&i.OriginalUrl,
		&i.PlaybackUrl,
		&i.ThumbnailUrl,
		&i.DurationSeconds,
		&i.FileSizeBytes,
		&i.Resolution,
		&i.Status,
		&i.ErrorMessage,
		&i.PostID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateVideoStatus = `-- name: UpdateVideoStatus :one
UPDATE videos
SET status = $2, error_message = $3, updated_at = NOW()
WHERE id = $1
RETURNING id, tenant_id, uploader_id, title, description, external_id, provider, original_url, playback_url, thumbnail_url, duration_seconds, file_size_bytes, resolution, status, error_message, post_id, created_at, updated_at
`

type UpdateVideoStatusParams struct {
	ID           uuid.UUID      `json:"id"`
	Status       string         `json:"status"`
	ErrorMessage sql.NullString `json:"error_message"`
}

func (q *Queries) UpdateVideoStatus(ctx context.Context, arg UpdateVideoStatusParams) (Video, error) {
	row := q.db.QueryRowContext(ctx, updateVideoStatus, arg.ID, arg.Status, arg.ErrorMessage)
	var i Video
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.UploaderID,
		&i.Title,
		&i.Description,
		&i.ExternalID,
		&i.Provider,
		&i.OriginalUrl,
		&i.PlaybackUrl,
		&i.ThumbnailUrl,
		&i.DurationSeconds,
		&i.FileSizeBytes,
		&i.Resolution,
		&i.Status,
		&i.ErrorMessage,
		&i.PostID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
