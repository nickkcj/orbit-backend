// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: lessons.sql

package database

import (
	"context"
	"database/sql"
	"time"

	"github.com/google/uuid"
)

const attachVideoToLesson = `-- name: AttachVideoToLesson :exec
UPDATE lessons SET video_id = $2, updated_at = NOW() WHERE id = $1
`

type AttachVideoToLessonParams struct {
	ID      uuid.UUID     `json:"id"`
	VideoID uuid.NullUUID `json:"video_id"`
}

func (q *Queries) AttachVideoToLesson(ctx context.Context, arg AttachVideoToLessonParams) error {
	_, err := q.db.ExecContext(ctx, attachVideoToLesson, arg.ID, arg.VideoID)
	return err
}

const countLessonsByCourse = `-- name: CountLessonsByCourse :one
SELECT COUNT(*) as count
FROM lessons l
JOIN modules m ON l.module_id = m.id
WHERE m.course_id = $1
`

func (q *Queries) CountLessonsByCourse(ctx context.Context, courseID uuid.UUID) (int64, error) {
	row := q.db.QueryRowContext(ctx, countLessonsByCourse, courseID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countLessonsByModule = `-- name: CountLessonsByModule :one
SELECT COUNT(*) as count FROM lessons WHERE module_id = $1
`

func (q *Queries) CountLessonsByModule(ctx context.Context, moduleID uuid.UUID) (int64, error) {
	row := q.db.QueryRowContext(ctx, countLessonsByModule, moduleID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createLesson = `-- name: CreateLesson :one

INSERT INTO lessons (tenant_id, module_id, title, description, content, content_format, video_id, position, duration_minutes, is_free_preview)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10)
RETURNING id, tenant_id, module_id, title, description, content, content_format, video_id, position, duration_minutes, is_free_preview, created_at, updated_at
`

type CreateLessonParams struct {
	TenantID        uuid.UUID      `json:"tenant_id"`
	ModuleID        uuid.UUID      `json:"module_id"`
	Title           string         `json:"title"`
	Description     sql.NullString `json:"description"`
	Content         sql.NullString `json:"content"`
	ContentFormat   string         `json:"content_format"`
	VideoID         uuid.NullUUID  `json:"video_id"`
	Position        int32          `json:"position"`
	DurationMinutes sql.NullInt32  `json:"duration_minutes"`
	IsFreePreview   bool           `json:"is_free_preview"`
}

// ============================================================================
// LESSONS
// ============================================================================
func (q *Queries) CreateLesson(ctx context.Context, arg CreateLessonParams) (Lesson, error) {
	row := q.db.QueryRowContext(ctx, createLesson,
		arg.TenantID,
		arg.ModuleID,
		arg.Title,
		arg.Description,
		arg.Content,
		arg.ContentFormat,
		arg.VideoID,
		arg.Position,
		arg.DurationMinutes,
		arg.IsFreePreview,
	)
	var i Lesson
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.ModuleID,
		&i.Title,
		&i.Description,
		&i.Content,
		&i.ContentFormat,
		&i.VideoID,
		&i.Position,
		&i.DurationMinutes,
		&i.IsFreePreview,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteLesson = `-- name: DeleteLesson :exec
DELETE FROM lessons WHERE id = $1
`

func (q *Queries) DeleteLesson(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, deleteLesson, id)
	return err
}

const detachVideoFromLesson = `-- name: DetachVideoFromLesson :exec
UPDATE lessons SET video_id = NULL, updated_at = NOW() WHERE id = $1
`

func (q *Queries) DetachVideoFromLesson(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, detachVideoFromLesson, id)
	return err
}

const getLessonByID = `-- name: GetLessonByID :one
SELECT id, tenant_id, module_id, title, description, content, content_format, video_id, position, duration_minutes, is_free_preview, created_at, updated_at FROM lessons WHERE id = $1
`

func (q *Queries) GetLessonByID(ctx context.Context, id uuid.UUID) (Lesson, error) {
	row := q.db.QueryRowContext(ctx, getLessonByID, id)
	var i Lesson
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.ModuleID,
		&i.Title,
		&i.Description,
		&i.Content,
		&i.ContentFormat,
		&i.VideoID,
		&i.Position,
		&i.DurationMinutes,
		&i.IsFreePreview,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getLessonWithVideo = `-- name: GetLessonWithVideo :one
SELECT
    l.id, l.tenant_id, l.module_id, l.title, l.description, l.content, l.content_format, l.video_id, l.position, l.duration_minutes, l.is_free_preview, l.created_at, l.updated_at,
    v.title as video_title,
    v.playback_url as video_playback_url,
    v.thumbnail_url as video_thumbnail_url,
    v.duration_seconds as video_duration,
    v.status as video_status
FROM lessons l
LEFT JOIN videos v ON l.video_id = v.id
WHERE l.id = $1
`

type GetLessonWithVideoRow struct {
	ID                uuid.UUID      `json:"id"`
	TenantID          uuid.UUID      `json:"tenant_id"`
	ModuleID          uuid.UUID      `json:"module_id"`
	Title             string         `json:"title"`
	Description       sql.NullString `json:"description"`
	Content           sql.NullString `json:"content"`
	ContentFormat     string         `json:"content_format"`
	VideoID           uuid.NullUUID  `json:"video_id"`
	Position          int32          `json:"position"`
	DurationMinutes   sql.NullInt32  `json:"duration_minutes"`
	IsFreePreview     bool           `json:"is_free_preview"`
	CreatedAt         time.Time      `json:"created_at"`
	UpdatedAt         time.Time      `json:"updated_at"`
	VideoTitle        sql.NullString `json:"video_title"`
	VideoPlaybackUrl  sql.NullString `json:"video_playback_url"`
	VideoThumbnailUrl sql.NullString `json:"video_thumbnail_url"`
	VideoDuration     sql.NullInt32  `json:"video_duration"`
	VideoStatus       sql.NullString `json:"video_status"`
}

func (q *Queries) GetLessonWithVideo(ctx context.Context, id uuid.UUID) (GetLessonWithVideoRow, error) {
	row := q.db.QueryRowContext(ctx, getLessonWithVideo, id)
	var i GetLessonWithVideoRow
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.ModuleID,
		&i.Title,
		&i.Description,
		&i.Content,
		&i.ContentFormat,
		&i.VideoID,
		&i.Position,
		&i.DurationMinutes,
		&i.IsFreePreview,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.VideoTitle,
		&i.VideoPlaybackUrl,
		&i.VideoThumbnailUrl,
		&i.VideoDuration,
		&i.VideoStatus,
	)
	return i, err
}

const getMaxLessonPosition = `-- name: GetMaxLessonPosition :one
SELECT COALESCE(MAX(position), -1)::int as max_position FROM lessons WHERE module_id = $1
`

func (q *Queries) GetMaxLessonPosition(ctx context.Context, moduleID uuid.UUID) (int32, error) {
	row := q.db.QueryRowContext(ctx, getMaxLessonPosition, moduleID)
	var max_position int32
	err := row.Scan(&max_position)
	return max_position, err
}

const listLessonsByCourse = `-- name: ListLessonsByCourse :many
SELECT
    l.id, l.tenant_id, l.module_id, l.title, l.description, l.content, l.content_format, l.video_id, l.position, l.duration_minutes, l.is_free_preview, l.created_at, l.updated_at,
    m.title as module_title,
    m.position as module_position,
    v.thumbnail_url as video_thumbnail_url,
    v.duration_seconds as video_duration
FROM lessons l
JOIN modules m ON l.module_id = m.id
LEFT JOIN videos v ON l.video_id = v.id
WHERE m.course_id = $1
ORDER BY m.position ASC, l.position ASC
`

type ListLessonsByCourseRow struct {
	ID                uuid.UUID      `json:"id"`
	TenantID          uuid.UUID      `json:"tenant_id"`
	ModuleID          uuid.UUID      `json:"module_id"`
	Title             string         `json:"title"`
	Description       sql.NullString `json:"description"`
	Content           sql.NullString `json:"content"`
	ContentFormat     string         `json:"content_format"`
	VideoID           uuid.NullUUID  `json:"video_id"`
	Position          int32          `json:"position"`
	DurationMinutes   sql.NullInt32  `json:"duration_minutes"`
	IsFreePreview     bool           `json:"is_free_preview"`
	CreatedAt         time.Time      `json:"created_at"`
	UpdatedAt         time.Time      `json:"updated_at"`
	ModuleTitle       string         `json:"module_title"`
	ModulePosition    int32          `json:"module_position"`
	VideoThumbnailUrl sql.NullString `json:"video_thumbnail_url"`
	VideoDuration     sql.NullInt32  `json:"video_duration"`
}

func (q *Queries) ListLessonsByCourse(ctx context.Context, courseID uuid.UUID) ([]ListLessonsByCourseRow, error) {
	rows, err := q.db.QueryContext(ctx, listLessonsByCourse, courseID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListLessonsByCourseRow
	for rows.Next() {
		var i ListLessonsByCourseRow
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.ModuleID,
			&i.Title,
			&i.Description,
			&i.Content,
			&i.ContentFormat,
			&i.VideoID,
			&i.Position,
			&i.DurationMinutes,
			&i.IsFreePreview,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ModuleTitle,
			&i.ModulePosition,
			&i.VideoThumbnailUrl,
			&i.VideoDuration,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listLessonsByModule = `-- name: ListLessonsByModule :many
SELECT
    l.id, l.tenant_id, l.module_id, l.title, l.description, l.content, l.content_format, l.video_id, l.position, l.duration_minutes, l.is_free_preview, l.created_at, l.updated_at,
    v.title as video_title,
    v.thumbnail_url as video_thumbnail_url,
    v.duration_seconds as video_duration,
    v.status as video_status
FROM lessons l
LEFT JOIN videos v ON l.video_id = v.id
WHERE l.module_id = $1
ORDER BY l.position ASC
`

type ListLessonsByModuleRow struct {
	ID                uuid.UUID      `json:"id"`
	TenantID          uuid.UUID      `json:"tenant_id"`
	ModuleID          uuid.UUID      `json:"module_id"`
	Title             string         `json:"title"`
	Description       sql.NullString `json:"description"`
	Content           sql.NullString `json:"content"`
	ContentFormat     string         `json:"content_format"`
	VideoID           uuid.NullUUID  `json:"video_id"`
	Position          int32          `json:"position"`
	DurationMinutes   sql.NullInt32  `json:"duration_minutes"`
	IsFreePreview     bool           `json:"is_free_preview"`
	CreatedAt         time.Time      `json:"created_at"`
	UpdatedAt         time.Time      `json:"updated_at"`
	VideoTitle        sql.NullString `json:"video_title"`
	VideoThumbnailUrl sql.NullString `json:"video_thumbnail_url"`
	VideoDuration     sql.NullInt32  `json:"video_duration"`
	VideoStatus       sql.NullString `json:"video_status"`
}

func (q *Queries) ListLessonsByModule(ctx context.Context, moduleID uuid.UUID) ([]ListLessonsByModuleRow, error) {
	rows, err := q.db.QueryContext(ctx, listLessonsByModule, moduleID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListLessonsByModuleRow
	for rows.Next() {
		var i ListLessonsByModuleRow
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.ModuleID,
			&i.Title,
			&i.Description,
			&i.Content,
			&i.ContentFormat,
			&i.VideoID,
			&i.Position,
			&i.DurationMinutes,
			&i.IsFreePreview,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.VideoTitle,
			&i.VideoThumbnailUrl,
			&i.VideoDuration,
			&i.VideoStatus,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const reorderLessonsAfterDelete = `-- name: ReorderLessonsAfterDelete :exec
UPDATE lessons
SET position = position - 1, updated_at = NOW()
WHERE module_id = $1 AND position > $2
`

type ReorderLessonsAfterDeleteParams struct {
	ModuleID uuid.UUID `json:"module_id"`
	Position int32     `json:"position"`
}

func (q *Queries) ReorderLessonsAfterDelete(ctx context.Context, arg ReorderLessonsAfterDeleteParams) error {
	_, err := q.db.ExecContext(ctx, reorderLessonsAfterDelete, arg.ModuleID, arg.Position)
	return err
}

const shiftLessonPositionsDown = `-- name: ShiftLessonPositionsDown :exec
UPDATE lessons
SET position = position - 1, updated_at = NOW()
WHERE module_id = $1 AND position > $2 AND position <= $3
`

type ShiftLessonPositionsDownParams struct {
	ModuleID   uuid.UUID `json:"module_id"`
	Position   int32     `json:"position"`
	Position_2 int32     `json:"position_2"`
}

func (q *Queries) ShiftLessonPositionsDown(ctx context.Context, arg ShiftLessonPositionsDownParams) error {
	_, err := q.db.ExecContext(ctx, shiftLessonPositionsDown, arg.ModuleID, arg.Position, arg.Position_2)
	return err
}

const shiftLessonPositionsUp = `-- name: ShiftLessonPositionsUp :exec
UPDATE lessons
SET position = position + 1, updated_at = NOW()
WHERE module_id = $1 AND position >= $2
`

type ShiftLessonPositionsUpParams struct {
	ModuleID uuid.UUID `json:"module_id"`
	Position int32     `json:"position"`
}

func (q *Queries) ShiftLessonPositionsUp(ctx context.Context, arg ShiftLessonPositionsUpParams) error {
	_, err := q.db.ExecContext(ctx, shiftLessonPositionsUp, arg.ModuleID, arg.Position)
	return err
}

const updateLesson = `-- name: UpdateLesson :one
UPDATE lessons
SET title = $2, description = $3, content = $4, content_format = $5, video_id = $6, duration_minutes = $7, is_free_preview = $8, updated_at = NOW()
WHERE id = $1
RETURNING id, tenant_id, module_id, title, description, content, content_format, video_id, position, duration_minutes, is_free_preview, created_at, updated_at
`

type UpdateLessonParams struct {
	ID              uuid.UUID      `json:"id"`
	Title           string         `json:"title"`
	Description     sql.NullString `json:"description"`
	Content         sql.NullString `json:"content"`
	ContentFormat   string         `json:"content_format"`
	VideoID         uuid.NullUUID  `json:"video_id"`
	DurationMinutes sql.NullInt32  `json:"duration_minutes"`
	IsFreePreview   bool           `json:"is_free_preview"`
}

func (q *Queries) UpdateLesson(ctx context.Context, arg UpdateLessonParams) (Lesson, error) {
	row := q.db.QueryRowContext(ctx, updateLesson,
		arg.ID,
		arg.Title,
		arg.Description,
		arg.Content,
		arg.ContentFormat,
		arg.VideoID,
		arg.DurationMinutes,
		arg.IsFreePreview,
	)
	var i Lesson
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.ModuleID,
		&i.Title,
		&i.Description,
		&i.Content,
		&i.ContentFormat,
		&i.VideoID,
		&i.Position,
		&i.DurationMinutes,
		&i.IsFreePreview,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateLessonPosition = `-- name: UpdateLessonPosition :exec
UPDATE lessons SET position = $2, updated_at = NOW() WHERE id = $1
`

type UpdateLessonPositionParams struct {
	ID       uuid.UUID `json:"id"`
	Position int32     `json:"position"`
}

func (q *Queries) UpdateLessonPosition(ctx context.Context, arg UpdateLessonPositionParams) error {
	_, err := q.db.ExecContext(ctx, updateLessonPosition, arg.ID, arg.Position)
	return err
}
