// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: analytics.sql

package database

import (
	"context"
	"database/sql"
	"time"

	"github.com/google/uuid"
)

const getMembersGrowth = `-- name: GetMembersGrowth :many
SELECT
    DATE(joined_at) as date,
    COUNT(*) as count
FROM tenant_members
WHERE tenant_id = $1
    AND joined_at >= $2
    AND status = 'active'
GROUP BY DATE(joined_at)
ORDER BY date
`

type GetMembersGrowthParams struct {
	TenantID uuid.UUID `json:"tenant_id"`
	JoinedAt time.Time `json:"joined_at"`
}

type GetMembersGrowthRow struct {
	Date  time.Time `json:"date"`
	Count int64     `json:"count"`
}

func (q *Queries) GetMembersGrowth(ctx context.Context, arg GetMembersGrowthParams) ([]GetMembersGrowthRow, error) {
	rows, err := q.db.QueryContext(ctx, getMembersGrowth, arg.TenantID, arg.JoinedAt)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetMembersGrowthRow
	for rows.Next() {
		var i GetMembersGrowthRow
		if err := rows.Scan(&i.Date, &i.Count); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPostsGrowth = `-- name: GetPostsGrowth :many
SELECT
    DATE(created_at) as date,
    COUNT(*) as count
FROM posts
WHERE tenant_id = $1
    AND created_at >= $2
    AND status = 'published'
GROUP BY DATE(created_at)
ORDER BY date
`

type GetPostsGrowthParams struct {
	TenantID  uuid.UUID `json:"tenant_id"`
	CreatedAt time.Time `json:"created_at"`
}

type GetPostsGrowthRow struct {
	Date  time.Time `json:"date"`
	Count int64     `json:"count"`
}

func (q *Queries) GetPostsGrowth(ctx context.Context, arg GetPostsGrowthParams) ([]GetPostsGrowthRow, error) {
	rows, err := q.db.QueryContext(ctx, getPostsGrowth, arg.TenantID, arg.CreatedAt)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetPostsGrowthRow
	for rows.Next() {
		var i GetPostsGrowthRow
		if err := rows.Scan(&i.Date, &i.Count); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRecentMembers = `-- name: GetRecentMembers :many
SELECT
    tm.user_id,
    tm.display_name,
    u.name as user_name,
    u.avatar_url,
    tm.joined_at
FROM tenant_members tm
JOIN users u ON tm.user_id = u.id
WHERE tm.tenant_id = $1 AND tm.status = 'active'
ORDER BY tm.joined_at DESC
LIMIT $2
`

type GetRecentMembersParams struct {
	TenantID uuid.UUID `json:"tenant_id"`
	Limit    int32     `json:"limit"`
}

type GetRecentMembersRow struct {
	UserID      uuid.UUID      `json:"user_id"`
	DisplayName sql.NullString `json:"display_name"`
	UserName    string         `json:"user_name"`
	AvatarUrl   sql.NullString `json:"avatar_url"`
	JoinedAt    time.Time      `json:"joined_at"`
}

func (q *Queries) GetRecentMembers(ctx context.Context, arg GetRecentMembersParams) ([]GetRecentMembersRow, error) {
	rows, err := q.db.QueryContext(ctx, getRecentMembers, arg.TenantID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetRecentMembersRow
	for rows.Next() {
		var i GetRecentMembersRow
		if err := rows.Scan(
			&i.UserID,
			&i.DisplayName,
			&i.UserName,
			&i.AvatarUrl,
			&i.JoinedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTenantStats = `-- name: GetTenantStats :one
SELECT
    (SELECT COUNT(*) FROM tenant_members tm WHERE tm.tenant_id = $1 AND tm.status = 'active') as total_members,
    (SELECT COUNT(*) FROM posts p WHERE p.tenant_id = $1 AND p.status = 'published') as total_posts,
    (SELECT COUNT(*) FROM comments c JOIN posts p ON c.post_id = p.id WHERE p.tenant_id = $1) as total_comments,
    (SELECT COALESCE(SUM(p2.view_count), 0) FROM posts p2 WHERE p2.tenant_id = $1) as total_views
`

type GetTenantStatsRow struct {
	TotalMembers  int64       `json:"total_members"`
	TotalPosts    int64       `json:"total_posts"`
	TotalComments int64       `json:"total_comments"`
	TotalViews    interface{} `json:"total_views"`
}

func (q *Queries) GetTenantStats(ctx context.Context, tenantID uuid.UUID) (GetTenantStatsRow, error) {
	row := q.db.QueryRowContext(ctx, getTenantStats, tenantID)
	var i GetTenantStatsRow
	err := row.Scan(
		&i.TotalMembers,
		&i.TotalPosts,
		&i.TotalComments,
		&i.TotalViews,
	)
	return i, err
}

const getTopPosts = `-- name: GetTopPosts :many
SELECT
    p.id,
    p.title,
    p.view_count,
    p.like_count,
    (SELECT COUNT(*) FROM comments WHERE post_id = p.id) as comment_count,
    p.created_at
FROM posts p
WHERE p.tenant_id = $1 AND p.status = 'published'
ORDER BY p.view_count DESC
LIMIT $2
`

type GetTopPostsParams struct {
	TenantID uuid.UUID `json:"tenant_id"`
	Limit    int32     `json:"limit"`
}

type GetTopPostsRow struct {
	ID           uuid.UUID `json:"id"`
	Title        string    `json:"title"`
	ViewCount    int32     `json:"view_count"`
	LikeCount    int32     `json:"like_count"`
	CommentCount int64     `json:"comment_count"`
	CreatedAt    time.Time `json:"created_at"`
}

func (q *Queries) GetTopPosts(ctx context.Context, arg GetTopPostsParams) ([]GetTopPostsRow, error) {
	rows, err := q.db.QueryContext(ctx, getTopPosts, arg.TenantID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTopPostsRow
	for rows.Next() {
		var i GetTopPostsRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.ViewCount,
			&i.LikeCount,
			&i.CommentCount,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
