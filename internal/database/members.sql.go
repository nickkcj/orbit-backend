// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: members.sql

package database

import (
	"context"
	"database/sql"
	"time"

	"github.com/google/uuid"
	"github.com/sqlc-dev/pqtype"
)

const addMember = `-- name: AddMember :one
INSERT INTO tenant_members (tenant_id, user_id, role_id, display_name)
VALUES ($1, $2, $3, $4)
RETURNING id, tenant_id, user_id, role_id, display_name, bio, status, joined_at, updated_at
`

type AddMemberParams struct {
	TenantID    uuid.UUID      `json:"tenant_id"`
	UserID      uuid.UUID      `json:"user_id"`
	RoleID      uuid.UUID      `json:"role_id"`
	DisplayName sql.NullString `json:"display_name"`
}

func (q *Queries) AddMember(ctx context.Context, arg AddMemberParams) (TenantMember, error) {
	row := q.db.QueryRowContext(ctx, addMember,
		arg.TenantID,
		arg.UserID,
		arg.RoleID,
		arg.DisplayName,
	)
	var i TenantMember
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.UserID,
		&i.RoleID,
		&i.DisplayName,
		&i.Bio,
		&i.Status,
		&i.JoinedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const countMembersByTenant = `-- name: CountMembersByTenant :one
SELECT COUNT(*) FROM tenant_members WHERE tenant_id = $1 AND status = 'active'
`

func (q *Queries) CountMembersByTenant(ctx context.Context, tenantID uuid.UUID) (int64, error) {
	row := q.db.QueryRowContext(ctx, countMembersByTenant, tenantID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getMember = `-- name: GetMember :one
SELECT id, tenant_id, user_id, role_id, display_name, bio, status, joined_at, updated_at FROM tenant_members WHERE tenant_id = $1 AND user_id = $2
`

type GetMemberParams struct {
	TenantID uuid.UUID `json:"tenant_id"`
	UserID   uuid.UUID `json:"user_id"`
}

func (q *Queries) GetMember(ctx context.Context, arg GetMemberParams) (TenantMember, error) {
	row := q.db.QueryRowContext(ctx, getMember, arg.TenantID, arg.UserID)
	var i TenantMember
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.UserID,
		&i.RoleID,
		&i.DisplayName,
		&i.Bio,
		&i.Status,
		&i.JoinedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getMemberProfile = `-- name: GetMemberProfile :one
SELECT
    tm.id, tm.tenant_id, tm.user_id, tm.role_id, tm.display_name, tm.bio, tm.status, tm.joined_at, tm.updated_at,
    u.email,
    u.name as user_name,
    u.avatar_url as user_avatar,
    r.slug as role_slug,
    r.name as role_name,
    (SELECT COUNT(*) FROM posts WHERE author_id = tm.user_id AND tenant_id = tm.tenant_id AND status = 'published') as post_count
FROM tenant_members tm
JOIN users u ON tm.user_id = u.id
JOIN roles r ON tm.role_id = r.id
WHERE tm.tenant_id = $1 AND tm.user_id = $2
`

type GetMemberProfileParams struct {
	TenantID uuid.UUID `json:"tenant_id"`
	UserID   uuid.UUID `json:"user_id"`
}

type GetMemberProfileRow struct {
	ID          uuid.UUID      `json:"id"`
	TenantID    uuid.UUID      `json:"tenant_id"`
	UserID      uuid.UUID      `json:"user_id"`
	RoleID      uuid.UUID      `json:"role_id"`
	DisplayName sql.NullString `json:"display_name"`
	Bio         sql.NullString `json:"bio"`
	Status      string         `json:"status"`
	JoinedAt    time.Time      `json:"joined_at"`
	UpdatedAt   time.Time      `json:"updated_at"`
	Email       string         `json:"email"`
	UserName    string         `json:"user_name"`
	UserAvatar  sql.NullString `json:"user_avatar"`
	RoleSlug    string         `json:"role_slug"`
	RoleName    string         `json:"role_name"`
	PostCount   int64          `json:"post_count"`
}

func (q *Queries) GetMemberProfile(ctx context.Context, arg GetMemberProfileParams) (GetMemberProfileRow, error) {
	row := q.db.QueryRowContext(ctx, getMemberProfile, arg.TenantID, arg.UserID)
	var i GetMemberProfileRow
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.UserID,
		&i.RoleID,
		&i.DisplayName,
		&i.Bio,
		&i.Status,
		&i.JoinedAt,
		&i.UpdatedAt,
		&i.Email,
		&i.UserName,
		&i.UserAvatar,
		&i.RoleSlug,
		&i.RoleName,
		&i.PostCount,
	)
	return i, err
}

const getMemberWithRole = `-- name: GetMemberWithRole :one
SELECT
    tm.id, tm.tenant_id, tm.user_id, tm.role_id, tm.display_name, tm.bio, tm.status, tm.joined_at, tm.updated_at,
    r.slug as role_slug,
    r.name as role_name,
    r.priority as role_priority
FROM tenant_members tm
JOIN roles r ON tm.role_id = r.id
WHERE tm.tenant_id = $1 AND tm.user_id = $2
`

type GetMemberWithRoleParams struct {
	TenantID uuid.UUID `json:"tenant_id"`
	UserID   uuid.UUID `json:"user_id"`
}

type GetMemberWithRoleRow struct {
	ID           uuid.UUID      `json:"id"`
	TenantID     uuid.UUID      `json:"tenant_id"`
	UserID       uuid.UUID      `json:"user_id"`
	RoleID       uuid.UUID      `json:"role_id"`
	DisplayName  sql.NullString `json:"display_name"`
	Bio          sql.NullString `json:"bio"`
	Status       string         `json:"status"`
	JoinedAt     time.Time      `json:"joined_at"`
	UpdatedAt    time.Time      `json:"updated_at"`
	RoleSlug     string         `json:"role_slug"`
	RoleName     string         `json:"role_name"`
	RolePriority int32          `json:"role_priority"`
}

func (q *Queries) GetMemberWithRole(ctx context.Context, arg GetMemberWithRoleParams) (GetMemberWithRoleRow, error) {
	row := q.db.QueryRowContext(ctx, getMemberWithRole, arg.TenantID, arg.UserID)
	var i GetMemberWithRoleRow
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.UserID,
		&i.RoleID,
		&i.DisplayName,
		&i.Bio,
		&i.Status,
		&i.JoinedAt,
		&i.UpdatedAt,
		&i.RoleSlug,
		&i.RoleName,
		&i.RolePriority,
	)
	return i, err
}

const listMembersByTenant = `-- name: ListMembersByTenant :many
SELECT
    tm.id, tm.tenant_id, tm.user_id, tm.role_id, tm.display_name, tm.bio, tm.status, tm.joined_at, tm.updated_at,
    u.email,
    u.name as user_name,
    u.avatar_url as user_avatar,
    r.slug as role_slug,
    r.name as role_name
FROM tenant_members tm
JOIN users u ON tm.user_id = u.id
JOIN roles r ON tm.role_id = r.id
WHERE tm.tenant_id = $1 AND tm.status = 'active'
ORDER BY tm.joined_at DESC
`

type ListMembersByTenantRow struct {
	ID          uuid.UUID      `json:"id"`
	TenantID    uuid.UUID      `json:"tenant_id"`
	UserID      uuid.UUID      `json:"user_id"`
	RoleID      uuid.UUID      `json:"role_id"`
	DisplayName sql.NullString `json:"display_name"`
	Bio         sql.NullString `json:"bio"`
	Status      string         `json:"status"`
	JoinedAt    time.Time      `json:"joined_at"`
	UpdatedAt   time.Time      `json:"updated_at"`
	Email       string         `json:"email"`
	UserName    string         `json:"user_name"`
	UserAvatar  sql.NullString `json:"user_avatar"`
	RoleSlug    string         `json:"role_slug"`
	RoleName    string         `json:"role_name"`
}

func (q *Queries) ListMembersByTenant(ctx context.Context, tenantID uuid.UUID) ([]ListMembersByTenantRow, error) {
	rows, err := q.db.QueryContext(ctx, listMembersByTenant, tenantID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListMembersByTenantRow
	for rows.Next() {
		var i ListMembersByTenantRow
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.UserID,
			&i.RoleID,
			&i.DisplayName,
			&i.Bio,
			&i.Status,
			&i.JoinedAt,
			&i.UpdatedAt,
			&i.Email,
			&i.UserName,
			&i.UserAvatar,
			&i.RoleSlug,
			&i.RoleName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTenantsByUser = `-- name: ListTenantsByUser :many
SELECT
    t.id, t.slug, t.name, t.description, t.logo_url, t.settings, t.status, t.billing_status, t.stripe_customer_id, t.stripe_subscription_id, t.plan_id, t.created_at, t.updated_at,
    tm.role_id,
    tm.display_name,
    tm.joined_at,
    r.slug as role_slug
FROM tenants t
JOIN tenant_members tm ON t.id = tm.tenant_id
JOIN roles r ON tm.role_id = r.id
WHERE tm.user_id = $1 AND tm.status = 'active' AND t.status = 'active'
ORDER BY tm.joined_at DESC
`

type ListTenantsByUserRow struct {
	ID                   uuid.UUID             `json:"id"`
	Slug                 string                `json:"slug"`
	Name                 string                `json:"name"`
	Description          sql.NullString        `json:"description"`
	LogoUrl              sql.NullString        `json:"logo_url"`
	Settings             pqtype.NullRawMessage `json:"settings"`
	Status               string                `json:"status"`
	BillingStatus        string                `json:"billing_status"`
	StripeCustomerID     sql.NullString        `json:"stripe_customer_id"`
	StripeSubscriptionID sql.NullString        `json:"stripe_subscription_id"`
	PlanID               sql.NullString        `json:"plan_id"`
	CreatedAt            time.Time             `json:"created_at"`
	UpdatedAt            time.Time             `json:"updated_at"`
	RoleID               uuid.UUID             `json:"role_id"`
	DisplayName          sql.NullString        `json:"display_name"`
	JoinedAt             time.Time             `json:"joined_at"`
	RoleSlug             string                `json:"role_slug"`
}

func (q *Queries) ListTenantsByUser(ctx context.Context, userID uuid.UUID) ([]ListTenantsByUserRow, error) {
	rows, err := q.db.QueryContext(ctx, listTenantsByUser, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListTenantsByUserRow
	for rows.Next() {
		var i ListTenantsByUserRow
		if err := rows.Scan(
			&i.ID,
			&i.Slug,
			&i.Name,
			&i.Description,
			&i.LogoUrl,
			&i.Settings,
			&i.Status,
			&i.BillingStatus,
			&i.StripeCustomerID,
			&i.StripeSubscriptionID,
			&i.PlanID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.RoleID,
			&i.DisplayName,
			&i.JoinedAt,
			&i.RoleSlug,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const removeMember = `-- name: RemoveMember :exec
DELETE FROM tenant_members WHERE tenant_id = $1 AND user_id = $2
`

type RemoveMemberParams struct {
	TenantID uuid.UUID `json:"tenant_id"`
	UserID   uuid.UUID `json:"user_id"`
}

func (q *Queries) RemoveMember(ctx context.Context, arg RemoveMemberParams) error {
	_, err := q.db.ExecContext(ctx, removeMember, arg.TenantID, arg.UserID)
	return err
}

const updateMemberProfile = `-- name: UpdateMemberProfile :one
UPDATE tenant_members
SET display_name = $3, bio = $4, updated_at = NOW()
WHERE tenant_id = $1 AND user_id = $2
RETURNING id, tenant_id, user_id, role_id, display_name, bio, status, joined_at, updated_at
`

type UpdateMemberProfileParams struct {
	TenantID    uuid.UUID      `json:"tenant_id"`
	UserID      uuid.UUID      `json:"user_id"`
	DisplayName sql.NullString `json:"display_name"`
	Bio         sql.NullString `json:"bio"`
}

func (q *Queries) UpdateMemberProfile(ctx context.Context, arg UpdateMemberProfileParams) (TenantMember, error) {
	row := q.db.QueryRowContext(ctx, updateMemberProfile,
		arg.TenantID,
		arg.UserID,
		arg.DisplayName,
		arg.Bio,
	)
	var i TenantMember
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.UserID,
		&i.RoleID,
		&i.DisplayName,
		&i.Bio,
		&i.Status,
		&i.JoinedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateMemberRole = `-- name: UpdateMemberRole :one
UPDATE tenant_members
SET role_id = $3, updated_at = NOW()
WHERE tenant_id = $1 AND user_id = $2
RETURNING id, tenant_id, user_id, role_id, display_name, bio, status, joined_at, updated_at
`

type UpdateMemberRoleParams struct {
	TenantID uuid.UUID `json:"tenant_id"`
	UserID   uuid.UUID `json:"user_id"`
	RoleID   uuid.UUID `json:"role_id"`
}

func (q *Queries) UpdateMemberRole(ctx context.Context, arg UpdateMemberRoleParams) (TenantMember, error) {
	row := q.db.QueryRowContext(ctx, updateMemberRole, arg.TenantID, arg.UserID, arg.RoleID)
	var i TenantMember
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.UserID,
		&i.RoleID,
		&i.DisplayName,
		&i.Bio,
		&i.Status,
		&i.JoinedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateMemberStatus = `-- name: UpdateMemberStatus :exec
UPDATE tenant_members
SET status = $3, updated_at = NOW()
WHERE tenant_id = $1 AND user_id = $2
`

type UpdateMemberStatusParams struct {
	TenantID uuid.UUID `json:"tenant_id"`
	UserID   uuid.UUID `json:"user_id"`
	Status   string    `json:"status"`
}

func (q *Queries) UpdateMemberStatus(ctx context.Context, arg UpdateMemberStatusParams) error {
	_, err := q.db.ExecContext(ctx, updateMemberStatus, arg.TenantID, arg.UserID, arg.Status)
	return err
}
